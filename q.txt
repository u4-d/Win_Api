主窗口中有3个子窗口
hLeftTop中有2个按钮, hLeftBottom是显示文字的区域, hRight是显示动画的区域.
当按下BUTTON_ANIMATE按钮后,需要调用AnimateImage在hRight子窗口中显示动画,
并且在hLeftBottom中调用DrawTextLines显示文字,应该如何修改下面的SubWndProc函数
LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    switch (uMsg) {
        case WM_SIZE: {
            // 获取主窗口的客户区大小
            RECT clientRect;
            GetClientRect(hwnd, &clientRect);

            // 计算宽度和高度
            int width = clientRect.right - clientRect.left;
            int height = clientRect.bottom - clientRect.top;

            // 左侧区域宽度（40%），右侧区域宽度（60%）
            int leftWidth = width * 40 / 100;
            int rightWidth = width - leftWidth;  // 右侧占 60%

            // 上下区域的高度比例（上3下7）
            int topHeight = height * 3 / 10;
            int bottomHeight = height - topHeight;

            // 调整子窗口的位置和大小
            // 左上窗口
            MoveWindow(hLeftTop, 0, 0, leftWidth, topHeight, TRUE);

            // 左下窗口
            MoveWindow(hLeftBottom, 0, topHeight, leftWidth, bottomHeight,
                       TRUE);

            // 右侧窗口
            MoveWindow(hRight, leftWidth, 0, rightWidth, height, TRUE);

            return 0;
        }

        case WM_CREATE: {
            // 创建子窗口：左上
            hLeftTop = CreateWindowEx(0, CHILD_CLASS_NAME, L"Left Top",
                                      WS_CHILD | WS_VISIBLE | WS_BORDER, 0, 0,
                                      0, 0, hwnd, nullptr,
                                      GetModuleHandle(nullptr), nullptr);

            // 创建子窗口：左下
            hLeftBottom = CreateWindowEx(0, CHILD_CLASS_NAME, L"Left Bottom",
                                         WS_CHILD | WS_VISIBLE | WS_BORDER, 0,
                                         0, 0, 0, hwnd, nullptr,
                                         GetModuleHandle(nullptr), nullptr);

            // 创建子窗口：右侧
            hRight = CreateWindowEx(0, CHILD_CLASS_NAME, L"Right Pane",
                                    WS_CHILD | WS_VISIBLE | WS_BORDER, 0, 0, 0,
                                    0, hwnd, nullptr, GetModuleHandle(nullptr),
                                    nullptr);
            createButton(hLeftTop);
            return 0;
        }

        case WM_DESTROY:
            PostQuitMessage(0);
            return 0;
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

// 子窗口过程（这里只是为了演示，可以在这里自定义每个子窗口的功能）
LRESULT CALLBACK SubWndProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                            LPARAM lParam) {
    // 根据窗口句柄判断当前是哪个子窗口
    if (hwnd == hLeftTop) {
        // 处理左上子窗口的消息
        switch (uMsg) {
            case WM_COMMAND:
                onCliecked(hRight, wParam);
                return 0;
            case WM_PAINT:
                // 绘制左上窗口内容
                break;
                // 其他左上窗口的消息处理
        }
    } else if (hwnd == hLeftBottom) {
        // 处理左下子窗口的消息
        switch (uMsg) {
            case WM_PAINT:
                // 绘制左下窗口内容
                break;
                // 其他左下窗口的消息处理
        }
    } else if (hwnd == hRight) {
        // 处理右侧子窗口的消息
        switch (uMsg) {
            case WM_PAINT: {
                PAINTSTRUCT ps;
                HDC hdc = BeginPaint(hRight, &ps);
                // 绘制图像动画
                if (isAnimating) {
                    AnimateImage(hdc, imageanime);  // 假设这是一个动画函数
                }
                EndPaint(hRight, &ps);
            }
                return 0;
            // 其他右侧窗口的消息处理
            case WM_COMMAND:
                onCliecked(hRight, wParam);
                return 0;
            case WM_TIMER:
                onTimer(hRight);
                break;
            case WM_MAKEGUAXIANG:
                showGuaImage(hRight);
                DrawTextLines();
                KillTimer(hRight, 1);
                break;
        }
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
void onCliecked(HWND hwnd, WPARAM wParam) {
    if (LOWORD(wParam) == BUTTON_ANIMATE) {
        switch (++btCnt) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                makeGua(hwnd);
                break;
            case 6:
                makeGua(hwnd);
                bt1Vis = FALSE;
                EnableWindow(bt1Hwnd, bt1Vis);
                break;
            default:

                break;
        }
    } else if (LOWORD(wParam) == BUTTON2) {
        resetBtnVis();
        EnableWindow(bt1Hwnd, bt1Vis);
    }
}

void AnimateImage(HDC hdc, const std::wstring& imagePath) {
    Graphics graphics(hdc);
    Image image(imagePath.c_str());

    int imgWidth = image.GetWidth();
    int imgHeight = image.GetHeight();

    // 根据当前帧计算缩放比例
    float scale = 1.0f - static_cast<float>(frame) / maxFrames;
    if (scale < 0.0f) scale = 0.0f;  // 确保比例不为负值

    int scaledWidth = static_cast<int>(imgWidth * scale);
    int scaledHeight = static_cast<int>(imgHeight * scale);
    RECT rc;
    GetClientRect(hRight, &rc);
    int centerX = (rc.right - rc.left) / 2;
    int centerY = (rc.bottom - rc.top) / 2;

    int x = centerX - scaledWidth / 2;
    int y = centerY - scaledHeight / 2;

    // 绘制缩放后的图片
    if (scaledWidth > 0 && scaledHeight > 0) {
        graphics.DrawImage(&image, x, y, scaledWidth, scaledHeight);
    }

    ++frame;  // 增加帧计数
}
void createButton(HWND hwnd) {
    bt1Hwnd =
        CreateWindow(L"BUTTON", L"摇挂",
                     WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON, 10,
                     10, 100, 50, hwnd, (HMENU)BUTTON_ANIMATE,
                     (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE), NULL);
    bt2Hwnd = CreateWindow(
        L"BUTTON", L"重新来过",
        WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON, 10, 60, 100, 50,
        hwnd, (HMENU)BUTTON2,
        (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE),  // 实例句柄
        NULL);  // 不需要额外数据
}
